# Задание с QML
Комментарии по выполнению задания находятся здесь https://disk.yandex.ru/d/Gy0PttzOZ_lPpg

# Задание с чёрным ящиком
Конечно же, всё зависит от количества входных чисел, однако первая зацепка, которая приходит на ум это то, что нет смысла хранить само число, необходимо хранить количество определённого числа, которое пришло. К примеру пришло число 7 увеличим переменную, которое хранит количество 7 на 1. Таким образом мы сможем в конце пройтись по этим перемнным и легко составить отсортированный список (пример: переменная для хранения 7 оказалась равной 3, следовательно у нас 777). <br> 

Чтобы это всё оптимизировать создадим: <br> 
1) QByteArray baData;
2) На старте заполним её значениями. Максимум мы можем передать туда значение 256, 0 мы передать не сможем. Поэтому будем заполнять по диапазону от -128 до 127 <br> 
   for (int i = 0; i < 257; i++) { <br> 
        baData.insert(i, -128); <br> 
    } <br>

3) Допустим на вход пришло некое число input. Тогда делаем:
    if(baData[input] < 127){ <br> 
        baData.insert(input, baData[input] + 1);  <br>          
    } <br>

4) Выведем  qDebug() << "baData sizeof = " + QString::number(sizeof(baData)); // Получим 24

5) Возвращаем baData из чёрного ящика. После по нему пройдутся циклом и получат отсортированный список. <br>

   for(int i = 0; i < baData.count; i++){ <br>
      baData[i]; // Например если i = 4, а baData[i] равна 6, тогда у нас получается 444444. По такому принципу мы получим отсортированный список. <br>
   } <br>

Этот способ корректно отработает при худшем случае 256 чисел (сразу пришло 256 одинаковых чисел) и при лучшем случае 65536 чисел (256 * 256). Если мы хотим это развить до большего количества входных чисел, тогда мы можем создать ещё один QByteArray, который тоже будет хранить 256 переменных, в которых будет записано количество раз когда перемнная из baData обнулилась (вернулась в значение -128), таким образом у нас будет 65536 * 256 = 16 777 216 и так далее...
